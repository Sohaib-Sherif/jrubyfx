=begin
JRubyFX - Write JavaFX and FXML in Ruby
Copyright (C) 2013 The JRubyFX Team

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
=end
require 'rubygems'
require 'rubygems/installer'
require 'rubygems/package_task'
require 'rdoc/task'
require_relative 'lib/jrubyfx_tasks'
require_relative 'lib/jrubyfx/version'
task :default => [:build, :run]

jar = ENV['jar'] || "jar"
target = ENV['target'] || "target"
output_jar = ENV['output_jar'] || "jrubyfx-app.jar"
main_script = ENV['main_script'] || nil
src = ENV['src'] || 'src/*'
jruby_version = ENV['jruby_version'] || JRUBY_VERSION || "1.7.1" #if they want speedy raking, use the default so they can use MRI or other rubies

base_dir = File.dirname(__FILE__)
cd base_dir unless Dir.pwd == base_dir
main_script = nil if main_script == "nil"

touch "lib/jrubyfx/core_ext/precompiled.rb" # Get around rake globbing issue

desc "Clean all build artifacts except jruby-complete.jar"
task :clean do
  rm_rf target if File.exists? target
  rm_rf "pkg" if File.exists? "pkg"
  rm_rf "doc" if File.exists? "doc"
  rm_rf "lib/jrubyfx/core_ext/precompiled.rb"
end

desc "Clean all build artifacts INCLUDING jruby-complete.jar"
task :clean_jruby => :clean do
  rm_rf "#{ENV['HOME']}/.jruby-jar"
end

desc "Precompile all the reflection"
task :reflect do
  require 'java' # for java_import
  require 'jruby/core_ext' # for the become_java!
 
  # generate imports file
  $WRITE_OUT = File.read("lib/jrubyfx/part_imports.rb")
  $WRITE_OUT = $WRITE_OUT[0..$WRITE_OUT.index('###### IMPORTANT LINE #####')]
  $WRITE_OUT << "\n\n    # The below lines are generated by `rake reflect`. Do not edit.\n\n"
  
  require_relative 'lib/jrubyfx/part_imports'
  
  File.open("lib/jrubyfx/imports.rb", "w") do |out|
    out << $WRITE_OUT
    $WRITE_OUT = nil
    out << <<ENDL
    
  end
end

ENDL
  end
  
  # Generate DSL table
  File.open("lib/jrubyfx/dsl_map.rb", "w") do |out|
    out << <<'ENDL'
=begin
JRubyFX - Write JavaFX and FXML in Ruby
Copyright (C) 2013 The JRubyFX Team

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
=end

# DO NOT MODIFY THIS FILE!
# This file is generated by the `rake reflect` task.

module JRubyFX
  module DSL
    NAME_TO_CLASSES = {
      # Manual overrides
      'observable_array_list' => proc { |*args| FXCollections.observable_array_list(*args) },
      'double_property' => SimpleDoubleProperty,
      'xy_chart_series' => Java::javafx.scene.chart.XYChart::Series,
      'xy_chart_data' => Java::javafx.scene.chart.XYChart::Data,
      # Automatically generated
ENDL
  
    out << (JRubyFX::FXImports::JFX_CLASS_HIERARCHY.flat_tree_inject(Hash) do |res, name, values|
        # Merge in auto-generated list of classes from all the imported classes
        unless values.is_a? Hash
          values.map do |i|
            # this regexp does snake_casing
            # TODO: Better way to get FULL class name
            res.merge!({i.snake_case.gsub(/(h|v)_(line|box)/, '\1\2') => i})
          end
          res
        else
          # we are not at a leaf node anymore, merge in previous work
          res.merge!(values)
        end
      end).map {|k, v| "      '#{k}' => #{v},"}.join("\n")
    
    # Add the custom ones
    out << <<'ENDL'

    }
  end
end
ENDL
  end

  # JRubyFX includes
  require_relative 'lib/jrubyfx/imports'
  require_relative 'lib/jrubyfx/module'
  require_relative 'lib/jrubyfx/dsl'
  fo = File.open("lib/jrubyfx/core_ext/precompiled.rb", "w")
  JRubyFX::DSL.compile_dsl(fo)
  fo.flush
  fo.close
  puts "Done Writing jrfx!"
end

desc "Run a script without installing the gem"
task :run => :reflect do
  ruby "-I lib '#{main_script||'samples/fxml/Demo.rb'}'"
end

task :gem => :reflect

# The gemspec exports the global $spec variable for us
load 'jrubyfx.gemspec'
Gem::PackageTask.new($spec) do |pkg|
  pkg.need_zip = false
  pkg.need_tar = false
end

desc "Build and install the gem"
task :install => :gem do
  Gem::Installer.new("pkg/jrubyfx-#{JRubyFX::VERSION}-java.gem").install
end

task :download_jruby_jar do
  JRubyFX::Tasks::download_jruby(jruby_version)
end

desc "Create a full jar with embedded JRuby and given script (via main_script and src ENV var)"
task :jar => [:clean, :download_jruby_jar, :precompile] do
  JRubyFX::Tasks::jarify_jrubyfx(src, main_script, target, output_jar, jar: jar)
end

desc "Create a full jar and run it"
task :run_jar => :jar do
  sh "java -jar #{target}/#{output_jar}"
end

RDoc::Task.new do |rdoc|
  files = ['lib'] # FIXME: readme and markdown
  rdoc.rdoc_files.add(files)
  rdoc.main = "README.md"
  rdoc.title = "JRubyFX Docs"
  rdoc.rdoc_dir = 'doc/'
end
